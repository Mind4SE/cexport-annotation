template st.CEXPORTHEADER : st.interfaces.IDL2C{
  $${
	  
isClient ::= [ "client" : "true" ]
isServer ::= [ "server" : "true" ]

/** 
 * Generates a ".c" header file.
 */

ProvidedSymbolsDeclaration(interfaceDefinition, prefix, itfName, idl) ::= <<
#ifndef __<prefix;format="toUpperCName">EXPORT_H__
#define __<prefix;format="toUpperCName">EXPORT_H__
/* 
 * This file is automatically generated by the CExport plugin.
 * It contains the declaration of symbols to access the interface
 * that was annotated with @CExport
 */
 
#include "mindcommon.h"
<idl.includes:includeDirective(include=it); separator="\n">

<interfaceDefinition.methods:{<declareCltMethod(prefix=prefix, itfName=itfName, method=it)>};separator="\n\n">

#endif //__<prefix;format="toUpperCName">EXPORT_H__


>>

RequiredSymbolsDeclaration(interfaceDefinition, prefix, itfName, idl) ::= <<
#ifndef __<prefix;format="toUpperCName">EXPORT_H__
#define __<prefix;format="toUpperCName">EXPORT_H__

/* 
 * This file is automatically generated by the CExport plugin.
 * It contains the declaration of symbols that are required by
 * interface that was annotated with @CExport
 */

#include "mindcommon.h"
<idl.includes:includeDirective(include=it); separator="\n">

<interfaceDefinition.methods:{<declareCltMethod(prefix=prefix, itfName=itfName, method=it)>};separator="\n\n">

#endif //__<prefix;format="toUpperCName">EXPORT_H__


>>


// -----------------------------------------------------------------------------
// Internal templates
// -----------------------------------------------------------------------------


includeDirective(include) ::= <<
#include <include.path;format="toIncludePath">
>>


dualMethPrototype(name, parameters) ::= <<
<name>(<parameters:parameterDef(parameter=it); separator=", ">, va_list param_list)
>>

methDef(itfName, method) ::= <<
<typeQualifier(qualifiers=method)><varDef(type=method.type, name=methodSignature(itfName = itfName, method=method))>
>>

methodSignature(itfName, method) ::= <<
METH(<itfName>, <method.name>)(<if(method.parameters)>
<method.parameters:parameterDef(parameter=it); separator=", "><if (method.vaArgs)>, ...<endif>
<else>
void
<endif>)
>>

cppMethCall(defName, itfName, method) ::= <<
PRIVATE.<defName>CPPInstance.<itfName>::<method.name>(<method.parameters:parameterName(parameter=it); separator=", ">)
>>

/////CLT

CltWrapper(idl, prefix, itfName) ::= <<
/* Generated interface wrapper. */
>>

ClientMethodsWrapper(itf, method) ::= <<
<if(method.vaArgs)>
<cppMethDef(itfName=itf.name+"Class", method=method)>{
  PRIVATE_DATA_T* _mind_this = (PRIVATE_DATA_T*) this->mind_context;
  <if (! (isVoidMethod(method=method)))><varDef(type=method.type, name="ret")>;<endif>
  va_list paramList;
  va_start(paramList, <last(method.parameters).name>);
  <if (! (isVoidMethod(method=method)))>
  ret = <endif>CALL(<itf.name>, <method.vaArgs.dualMethodName>)(<method.parameters:parameterName(parameter=it); separator=", ">, paramList);
  va_end(paramList);
  <if (! (isVoidMethod(method=method)))>
  return ret;
  <endif>
<else>
<cppMethDef(itfName=itf.name+"Class", method=method)>{
  PRIVATE_DATA_T* _mind_this = (PRIVATE_DATA_T*) this->mind_context;
  <if (! (isVoidMethod(method=method)))>
  return <endif><methCall(itfName=itf.name,method=method)>;
<endif>
}
>>

declareCltMethod(prefix, itfName, method) ::= <<
<if(method.vaArgs)>
<cMethDef(prefix=prefix, itfName=itfName, method=method)>;
<else>
<cMethDef(prefix=prefix, itfName=itfName, method=method)>;
<endif>
>>

cMethDef(prefix, itfName, method) ::= <<
<typeQualifier(qualifiers=method)><varDef(type=method.type, name=cMethodSignature(prefix = prefix, method=method))>
>>

cMethodSignature(prefix, method) ::= <<
<prefix><method.name>(<if(method.parameters)>
<method.parameters:parameterDef(parameter=it); separator=", "><if (method.vaArgs)>, ...<endif>
<else>
void
<endif>)
>>

methCall(itfName,method) ::= <<
CALL(<itfName>,<method.name>)(<method.parameters:parameterName(parameter=it); separator=", ">)
>>





  }$$
}
  